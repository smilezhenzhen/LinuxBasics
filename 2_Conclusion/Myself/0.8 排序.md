---
typora-copy-images-to: assets
---

参考：https://time.geekbang.org/column/article/41802#previewimg

https://time.geekbang.org/column/article/42038#previewimg

### 0 排序简介

最经典的排序算法包括：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序等，按照时间复杂度可以分为三类。

![img](D:\Git\2_Conclusion\Myself\assets\fb8394a588b12ff6695cfd664afb17cd.jpg)

### 1 冒泡排序&插入排序&选择排序

#### 1.1 排序算法的执行效率

（1）最好情况、最坏情况、平均情况时间复杂度：有些排序算法会区分，为了好对比，所以最好都做一个区分；对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，要知道排序算法在不同数据下的性能表现。

（2）时间复杂度的系数、常数、低阶

（3）比较次数和交换（或移动）次数

#### 1.2 排序算法的内存消耗

排序算法的内存消耗可以通过空间复杂度来衡量

#### 1.3 排序算法的稳定性

稳定性是指如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。实际开发中，排序的往往不是单纯的整数，而是一组对象，需要按照对象的某个key来排序。

对于电商交易系统中的“订单”排序，先按下单时间给订单排序，排序完成后使用稳定排序算法按照订单金额重新排序，两遍排序之后得到的订单数据即是按照金额从小到大，金额相同的订单按照下单时间从早到晚排序。

稳定排序算法可以保持金额相同的两个对象在排序之后的前后顺序不变。第一次排序之后，所有的订单按照下单时间从早到晚有序；第二次排序中，使用最稳定的排序算法保证相同金额的订单仍然保持下单时间的从早到晚。

![1566000718612](D:\Git\2_Conclusion\Myself\assets\1566000718612.png)

#### 1.4 冒泡排序(Bubble Sort)

冒泡排序只会操作相邻的两个数据，每次操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，不满足则交换，一次冒泡会让至少一个元素移动到它应该在的位置，重复n次即完成了n个数据的排序工作。

![1566001013465](D:\Git\2_Conclusion\Myself\assets\1566001013465.png)

![1566001178471](D:\Git\2_Conclusion\Myself\assets\1566001178471.png)

冒泡排序的具体实现代码为：

```c++
// 冒泡排序，a 表示数组，n 表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
```

（1）冒泡排序是一个原地排序算法，空间复杂度为O(1)

（2）冒泡排序是稳定的排序算法，相邻两个元素大小相等时不进行交换

（3）冒泡排序的时间复杂度最坏情况是O(n*n)

#### 1.5 插入排序(Insertion Sort)

将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，即数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素位置为空，算法结束。

![1566002322919](D:\Git\2_Conclusion\Myself\assets\1566002322919.png)

插入排序的代码实现如下：

```c++
// 插入排序，a 表示数组，n 表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```

（1）插入排序是一个原地排序算法，空间复杂度为O(1)

（2）插入排序是稳定的排序算法，对于值相同的元素，可以选择将后面出现的元素插入到前面出现的后面，即可保证原有的前后顺序不变。

（3）插入排序的时间复杂度最坏情况是O(n*n)

#### 1.6 选择排序(Selection Sort)

选择排序的思路与插入排序类似，分为已排序区间和未排序区间，选择排序每次会从排序区间中找到最小的元素，将其放到已排序区间的末尾。

![img](D:\Git\2_Conclusion\Myself\assets\32371475a0b08f0db9861d102474181d.jpg)

（1）选择排序是一个原地排序算法，空间复杂度为O(1)

（2）选择排序是不稳定的排序算法，每次排序需要找到剩余未排序元素的最小值，并和前面的元素交换位置，破坏了稳定性。

（3）插入排序的时间复杂度最坏情况是O(n*n)

![img](D:\Git\2_Conclusion\Myself\assets\348604caaf0a1b1d7fee0512822f0e50.jpg)

### 2 归并排序&快速排序

#### 2.1 归并排序(Merge Sort)

归并排序使用分治的思想，讲一个大问题分解为多个子问题来解决。如果要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，以此类推。分治算法一般都是用递归来实现的，分治是一种解决问题的处理思想，递归是一种编程技巧。

![img](D:\Git\2_Conclusion\Myself\assets\db7f892d3355ef74da9cd64aa926dc2b.jpg)

归并排序的递推公式为：

```c++
递推公式：
merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))

终止条件：
p >= r 不用再继续分解
```

归并排序的伪代码如下：

```c++
// 归并排序算法, A 是数组，n 表示数组大小
merge_sort(A, n) {
  merge_sort_c(A, 0, n-1)
}

// 递归调用函数
merge_sort_c(A, p, r) {
  // 递归终止条件
  if p >= r  then return

  // 取 p 到 r 之间的中间位置 q
  q = (p+r) / 2
  // 分治递归
  merge_sort_c(A, p, q)
  merge_sort_c(A, q+1, r)
  / 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]
  merge(A[p...r], A[p...q], A[q+1...r])
}
```

merge(A[p...r], A[p...q], A[q+1...r])函数的作用是将两个已排序好的子数组合并为一个有序的数组，具体做法是使用两个游标i、j，分别指向A[p...q]、A[q+1...r]的第一个元素，比较A[i]与A[j]；如果 A[i]<=A[j]，我们就把 A[i] 放入到临时数组 tmp，并且 i 后移一位，否则将 A[j] 放入到数组tmp，j 后移一位。

![img](D:\Git\2_Conclusion\Myself\assets\95897ade4f7ad5d10af057b1d144a22f.jpg)

merge()函数的伪代码如下：

```c++
merge(A[p...r], A[p...q], A[q+1...r]) {
  var i := p，j := q+1，k := 0 // 初始化变量 i, j, k
  var tmp := new array[0...r-p] // 申请一个大小跟 A[p...r] 一样的临时数组
  while i<=q AND j<=r do {
    if A[i] <= A[j] {
      tmp[k++] = A[i++] // i++ 等于 i:=i+1
    } else {
      tmp[k++] = A[j++]
    }
  }
  
  // 判断哪个子数组中有剩余的数据
  var start := i，end := q
  if j<=r then start := j, end:=r
  
  // 将剩余的数据拷贝到临时数组 tmp
  while start <= end do {
    tmp[k++] = A[start++]
  }
  
  // 将 tmp 中的数组拷贝回 A[p...r]
  for i:=0 to r-p do {
    A[p+i] = tmp[i]
  }
}
```

（1）归并排序不是原地排序算法，空间复杂度为O(n)

（2）归并排序的稳定与否要看merge(函数)，在合并过程中，可以保证值相同的元素在合并前后的先后顺序，即归并排序是一个稳定的排序算法。

（3）归并排序的时间复杂度最坏情况是O(nlogn)：不仅递归求解的问题可以写成递推公式，递推代码的时间复杂度也可以写成递推公式

#### 2.2 快速排序(Quick Sort)

如果要排序中下标从p到r之间的一组数据，选择p到r之间的任意一个数据作为分区点pivot，遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将pivot放到中间。经过上述步骤之后，数组p到r之间的数据被分成三个部分，前面p到q-1之间都小于pivot，中间为pivot，后面的q+1到r之间的都大于pivot。根据分治、递归的处理思想，用递归排序下标从p到q-1之间的数据和下标q-1到r之间的数据，知道区间缩小为1，即说明所有的数据有序。具体的递推公式如下：

```c++
递推公式：
quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)

终止条件：
p >= r
```

伪代码如下：

```c++
// 快速排序，A 是数组，n 表示数组的大小
quick_sort(A, n) {
  quick_sort_c(A, 0, n-1)
}
// 快速排序递归函数，p,r 为下标
quick_sort_c(A, p, r) {
  if p >= r then return
  
  q = partition(A, p, r) // 获取分区点
  quick_sort_c(A, p, q-1)
  quick_sort_c(A, q+1, r)
}
```

分区函数partition(A, p, r)的伪代码为：

```c++
partition(A, p, r) {
  pivot := A[r]
  i := p
  for j := p to r-1 do {
    if A[j] < pivot {
      swap A[i] with A[j]
      i := i+1
    }
  }
  swap A[i] with A[r]
  return i
```

![img](D:\Git\2_Conclusion\Myself\assets\086002d67995e4769473b3f50dd96de7.jpg)

（1）快速排序是原地排序算法，空间复杂度为O(1)

（2）快速排序是一个不稳定的排序算法

（3）快速排序的时间复杂度最坏情况是O(nlogn)

#### 2.3 归并排序与快速牌数的区别

归并排序的处理过程是由下而上，先处理子问题，然后再合并。快速排序正好相反，处理过程由上到下，先分区，再处理子问题。归并排序的合并函数无法在原地执行，快速排序通过设计巧妙的原地分区函数，实现原地排序，解决归并排序占用太多内存的问题。

![img](D:\Git\2_Conclusion\Myself\assets\aa03ae570dace416127c9ccf9db8ac05.jpg)

#### 2.4 用快速排序在O(n)内查找第K大元素

选择数组区间A[0...n-1]的最后一个元素A[n-1]作为pivot，对数组A[0...n-1]原地分区。如果p+1=K，那A[p]就是要求解的元素；如果K>p+1说明第K大元素出现在A[p+1,n-1]区间，按照上面的思路递归在A[p+1,n-1]这个区间内查找；如果K<p+1，在A[0…p-1] 区间查找。

![img](D:\Git\2_Conclusion\Myself\assets\898d94fc32e0a795fd65897293b98791.jpg)

#### 2.5 课后思考

![1566029513228](D:\Git\2_Conclusion\Myself\assets\1566029513228.png)

### 3 线性排序

桶排序、计数排序、基数排序都属于线性排序，这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。

#### 3.1 桶排序(Bucket sort)

桶排序的核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排序完之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的。

![img](D:\Git\2_Conclusion\Myself\assets\987564607b864255f81686829503abae.jpg)

桶排序的时间复杂度为O(n)，但是对要排序数据的要求是非常苛刻的。首先要排序的数据需要很容易的就能划分成m个桶，桶与桶之间有着天然的大小顺序。每个桶内的数据排序完之后，桶与桶之间的数据不需要再进行排序。其次，数据再每个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶的数据非常多，有些非常少，不平均的话，那桶内数据排序的时间复杂度就不是常量极了。桶排序比较适合用在外部排序中，即数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

例子：有10G的订单数据，希望按照订单金额进行排序，但是内存有限，只有几百MB，没办法一次性将10GB的数据都加载到内存中。

![1566286166880](D:\Git\2_Conclusion\Myself\assets\1566286166880.png)

#### 3.2 计数排序(Counting sort)

计数排序是一种特殊的桶排序，当要排序的n个数据，范围不大，最大值为k，可以将数据划分为k个桶，每个桶的数据都是相同的，省掉了桶内排序的时间。

例子：高考的查分系统，会显示成绩及所在省排名，拿一个简单的例子进行解释。假设只有8个考生，分数在0-5分之间，这8个考生的成绩统一放到数组A[8中]，分别是2,5,3,0,2,3,0,3。使用大小为6的数组C[6]表示桶，其中下标对应分数，C[6]中存储的并不是考生，而是对应的考生个数，遍历一遍考生分数，即可得到C[6]的值。

![img](D:\Git\2_Conclusion\Myself\assets\adc75672ef33fa54b023a040834fcbc9.jpg)

分数为3分的考生有3个，小于3分的考生有4个，故成绩为3分的考生在排序之后的有序数组R[8]中保存在下标4,5,6的位置。

![img](D:\Git\2_Conclusion\Myself\assets\361f4d781d2a2d144dcbbbb0b9e6db29.jpg)

如何快速计算出每个分数的考生在有序数组中对应的存储位置呢，对C[6]数组顺序求和，则C[k]中存储小于等于分数k的考生个数。

![img](D:\Git\2_Conclusion\Myself\assets\dd6c62b12b0dc1b3a294af0fa1ce371f.jpg)

![1566285454669](D:\Git\2_Conclusion\Myself\assets\1566285454669.png)

![img](D:\Git\2_Conclusion\Myself\assets\1d730cb17249f8e92ef5cab53ae65784.jpg)

具体代码如下：

```c++
// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。
public void countingSort(int[] a, int n) {
  if (n <= 1) return;

  // 查找数组中数据的范围
  int max = a[0];
  for (int i = 1; i < n; ++i) {
    if (max < a[i]) {
      max = a[i];
    }
  }

  int[] c = new int[max + 1]; // 申请一个计数数组 c，下标大小 [0,max]
  for (int i = 0; i <= max; ++i) {
    c[i] = 0;
  }

  // 计算每个元素的个数，放入 c 中
  for (int i = 0; i < n; ++i) {
    c[a[i]]++;
  }

  // 依次累加
  for (int i = 1; i <= max; ++i) {
    c[i] = c[i-1] + c[i];
  }

  // 临时数组 r，存储排序之后的结果
  int[] r = new int[n];
  // 计算排序的关键步骤，有点难理解
  for (int i = n - 1; i >= 0; --i) {
    int index = c[a[i]]-1;
    r[index] = a[i];
    c[a[i]]--;
  }

  // 将结果拷贝给 a 数组
  for (int i = 0; i < n; ++i) {
    a[i] = r[i];
  }
}
```

计数排序只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不适合用计数排序。同时计数排序只能给非负整数排序，如果要要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。

#### 3.3 基数排序(Radix sort)

对10万个手机号码进行排序。

#### 3.4 根据年龄对100万用户排序

假设年龄范围是1-120，遍历这100万用户，根据年龄将其划分到120个桶里，然后依次顺序遍历这120个桶中的元素，即可得到按照年龄排序的100万用户数据。

#### 3.5 总结与思考

桶排序与计数排序的排序思想是非常相似的，针对范围不大的数据，将数据划分为不同的桶来实现排序。计数排序要求数据可以划分为高低位，位之间有递进关系，比较两个数，只需要比较高位，高位相同的再比较低位，而且每一位的数据范围不能太大，因为计数排序算法需要借助桶排序或者计数排序来完成每一位的排序工作。

![1566286077744](D:\Git\2_Conclusion\Myself\assets\1566286077744.png)